[
  {
    "title": "Building Modern Web Applications with Next.js and Velite",
    "slug": "building-modern-web-apps",
    "description": "Learn how to create fast, scalable, and maintainable web applications using Next.js and Velite for content management",
    "date": "2024-01-10T00:00:00.000Z",
    "draft": false,
    "featured": true,
    "category": "tutorial",
    "tags": [
      "nextjs",
      "velite",
      "web-development",
      "react",
      "typescript"
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 510
    },
    "excerpt": "Building Modern Web Applications with Next.js and Velite\nIn today's fast-paced web development landscape, creating performant, scalable, and maintainable applications is crucial. Next.js combined with Velite provides an excellent foundation for building modern",
    "content": "<h1>Building Modern Web Applications with Next.js and Velite</h1>\n<p>In today's fast-paced web development landscape, creating performant, scalable, and maintainable applications is crucial. Next.js combined with Velite provides an excellent foundation for building modern web applications.</p>\n<h2>Why Next.js?</h2>\n<p>Next.js offers several advantages that make it ideal for modern web development:</p>\n<h3>Performance Benefits</h3>\n<ul>\n<li><strong>Server-Side Rendering (SSR)</strong>: Improves initial page load and SEO</li>\n<li><strong>Static Site Generation (SSG)</strong>: Pre-render pages at build time for optimal performance</li>\n<li><strong>Automatic Code Splitting</strong>: Loads only the JavaScript needed for each page</li>\n<li><strong>Image Optimization</strong>: Built-in image optimization with Next.js Image component</li>\n</ul>\n<h3>Developer Experience</h3>\n<ul>\n<li><strong>File-based Routing</strong>: Intuitive routing system based on file structure</li>\n<li><strong>API Routes</strong>: Create API endpoints within your Next.js application</li>\n<li><strong>TypeScript Support</strong>: First-class TypeScript integration</li>\n<li><strong>Hot Module Replacement</strong>: Fast development with instant updates</li>\n</ul>\n<h2>Velite: Content Management Made Easy</h2>\n<p>Velite is a powerful static site generator that works seamlessly with Next.js. It provides:</p>\n<h3>Schema-Driven Content</h3>\n<pre><code class=\"language-typescript\">// Define your content schema\nconst postSchema = s.object({\n  title: s.string().max(99),\n  slug: s.slug('global', ['title']),\n  description: s.string().max(199).optional(),\n  date: s.isodate(),\n  content: s.markdown(),\n  tags: s.array(s.string()).default([]),\n})\n</code></pre>\n<h3>Type-Safe Content Access</h3>\n<pre><code class=\"language-typescript\">import { posts } from '.velite'\n\n// Fully typed content access\nconst blogPosts = posts.filter(post => post.featured)\n</code></pre>\n<h2>Getting Started</h2>\n<h3>1. Project Setup</h3>\n<pre><code class=\"language-bash\">npx create-next-app@latest my-app\ncd my-app\nnpm install velite zod\n</code></pre>\n<h3>2. Velite Configuration</h3>\n<p>Create a <code>velite.config.ts</code> file:</p>\n<pre><code class=\"language-typescript\">import { defineConfig, s } from 'velite'\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post',\n      pattern: 'posts/**/*.md',\n      schema: s.object({\n        title: s.string().max(99),\n        slug: s.slug('global', ['title']),\n        description: s.string().max(199).optional(),\n        date: s.isodate(),\n        content: s.markdown(),\n        tags: s.array(s.string()).default([]),\n      }),\n    },\n  },\n})\n</code></pre>\n<h3>3. Content Structure</h3>\n<pre><code>content/\n├── posts/\n│   ├── welcome.md\n│   └── getting-started.md\n└── pages/\n    └── about.md\n</code></pre>\n<h2>Best Practices</h2>\n<h3>Content Organization</h3>\n<ul>\n<li>Use descriptive filenames that match your URL structure</li>\n<li>Include frontmatter for metadata like title, description, and tags</li>\n<li>Organize content into logical collections (posts, pages, authors)</li>\n</ul>\n<h3>Performance Optimization</h3>\n<ul>\n<li>Use <code>getStaticProps</code> for data fetching at build time</li>\n<li>Implement proper image optimization</li>\n<li>Utilize Next.js caching strategies</li>\n</ul>\n<h3>SEO Considerations</h3>\n<ul>\n<li>Use semantic HTML structure</li>\n<li>Implement proper meta tags</li>\n<li>Create XML sitemaps</li>\n<li>Optimize for Core Web Vitals</li>\n</ul>\n<h2>Advanced Features</h2>\n<h3>Dynamic Routing</h3>\n<p>Create dynamic pages for blog posts:</p>\n<pre><code class=\"language-typescript\">// pages/blog/[slug].tsx\nexport async function getStaticPaths() {\n  return {\n    paths: posts.map(post => ({ params: { slug: post.slug } })),\n    fallback: false,\n  }\n}\n</code></pre>\n<h3>Content Relationships</h3>\n<p>Link related content and authors:</p>\n<pre><code class=\"language-typescript\">// Find posts by an author\nconst authorPosts = posts.filter(post => post.author === 'john-doe')\n</code></pre>\n<h2>Deployment</h2>\n<p>Deploy your Next.js and Velite application to platforms like:</p>\n<ul>\n<li><strong>Vercel</strong>: Optimized for Next.js with automatic deployments</li>\n<li><strong>Netlify</strong>: Great for static sites with continuous deployment</li>\n<li><strong>Railway</strong>: Full-stack deployment with databases</li>\n</ul>\n<h2>Conclusion</h2>\n<p>Next.js and Velite provide a powerful combination for building modern web applications. The schema-driven approach ensures type safety and maintainability, while Next.js handles the complex parts of web application development.</p>\n<p>Start small, follow best practices, and gradually add complexity as your application grows. The result will be a fast, scalable, and maintainable web application that provides an excellent user experience.</p>\n<p>Happy coding! 🚀</p>"
  },
  {
    "title": "React Performance Optimization Techniques",
    "slug": "react-performance-optimization",
    "description": "Master React performance optimization with code splitting, memoization, and rendering strategies",
    "date": "2024-01-05T00:00:00.000Z",
    "draft": false,
    "featured": false,
    "category": "tutorial",
    "tags": [
      "react",
      "performance",
      "optimization",
      "hooks",
      "rendering"
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 645
    },
    "excerpt": "React Performance Optimization Techniques\nPerformance is crucial for user experience. Here are proven techniques to optimize your React applications for better performance and user satisfaction.\n1. Code Splitting\nBreak your application into smaller chunks that",
    "content": "<h1>React Performance Optimization Techniques</h1>\n<p>Performance is crucial for user experience. Here are proven techniques to optimize your React applications for better performance and user satisfaction.</p>\n<h2>1. Code Splitting</h2>\n<p>Break your application into smaller chunks that load on demand.</p>\n<h3>Route-Based Code Splitting</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\n\nfunction App() {\n  return (\n    &#x3C;Suspense fallback={&#x3C;LoadingSpinner />}>\n      &#x3C;Routes>\n        &#x3C;Route path=\"/\" element={&#x3C;Home />} />\n        &#x3C;Route path=\"/about\" element={&#x3C;About />} />\n      &#x3C;/Routes>\n    &#x3C;/Suspense>\n  );\n}\n</code></pre>\n<h3>Component-Based Code Splitting</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nconst ExpensiveComponent = lazy(() =>\n  import('./components/ExpensiveComponent')\n);\n\nfunction Dashboard() {\n  const [showExpensive, setShowExpensive] = useState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;button onClick={() => setShowExpensive(true)}>\n        Load Expensive Component\n      &#x3C;/button>\n      {showExpensive &#x26;&#x26; (\n        &#x3C;Suspense fallback={&#x3C;div>Loading...&#x3C;/div>}>\n          &#x3C;ExpensiveComponent />\n        &#x3C;/Suspense>\n      )}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>2. React.memo and useMemo</h2>\n<h3>Memoizing Components</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nconst ExpensiveList = memo(({ items, onItemClick }: Props) => {\n  console.log('Rendering ExpensiveList');\n  return (\n    &#x3C;ul>\n      {items.map(item => (\n        &#x3C;ListItem key={item.id} item={item} onClick={onItemClick} />\n      ))}\n    &#x3C;/ul>\n  );\n});\n</code></pre>\n<h3>Memoizing Expensive Calculations</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nfunction ProductList({ products }: { products: Product[] }) {\n  const sortedProducts = useMemo(() =>\n    [...products].sort((a, b) => b.price - a.price),\n    [products]\n  );\n\n  return (\n    &#x3C;div>\n      {sortedProducts.map(product => (\n        &#x3C;ProductCard key={product.id} product={product} />\n      ))}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>3. useCallback for Stable References</h2>\n<pre><code class=\"language-typescript\">// ✅ Good\nconst handleItemClick = useCallback((itemId: string) => {\n  console.log('Item clicked:', itemId);\n}, []); // Empty dependency array for stable reference\n\nconst ExpensiveList = memo(({ onItemClick }: Props) => {\n  return (\n    &#x3C;ul>\n      {items.map(item => (\n        &#x3C;button key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        &#x3C;/button>\n      ))}\n    &#x3C;/ul>\n  );\n});\n</code></pre>\n<h2>4. Virtualization for Large Lists</h2>\n<p>For lists with thousands of items, use virtualization:</p>\n<pre><code class=\"language-typescript\">import { FixedSizeList as List } from 'react-window';\n\n// ✅ Good for large lists\nfunction LargeList({ items }: { items: Item[] }) {\n  return (\n    &#x3C;List\n      height={400}\n      itemCount={items.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {({ index, style }) => (\n        &#x3C;div style={style}>\n          &#x3C;ListItem item={items[index]} />\n        &#x3C;/div>\n      )}\n    &#x3C;/List>\n  );\n}\n</code></pre>\n<h2>5. Image Optimization</h2>\n<h3>Next.js Image Component</h3>\n<pre><code class=\"language-typescript\">import Image from 'next/image';\n\n// ✅ Good\nfunction ProductImage({ src, alt }: { src: string; alt: string }) {\n  return (\n    &#x3C;Image\n      src={src}\n      alt={alt}\n      width={400}\n      height={300}\n      placeholder=\"blur\"\n      blurDataURL=\"data:image/jpeg;base64,...\"\n      loading=\"lazy\"\n    />\n  );\n}\n</code></pre>\n<h2>6. Bundle Analysis</h2>\n<p>Use tools to analyze your bundle size:</p>\n<pre><code class=\"language-bash\"># Install bundle analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n# Add to next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n});\n\nmodule.exports = withBundleAnalyzer({});\n</code></pre>\n<h2>7. Performance Monitoring</h2>\n<h3>Web Vitals</h3>\n<pre><code class=\"language-typescript\">import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nfunction reportWebVitals({ name, delta, value, id }: Metric) {\n  // Send to analytics service\n  console.log({ name, delta, value, id });\n}\n\n// Use in your app\nuseEffect(() => {\n  getCLS(reportWebVitals);\n  getFID(reportWebVitals);\n  getFCP(reportWebVitals);\n  getLCP(reportWebVitals);\n  getTTFB(reportWebVitals);\n}, []);\n</code></pre>\n<h2>8. React DevTools Profiler</h2>\n<p>Use React DevTools Profiler to identify performance bottlenecks:</p>\n<ol>\n<li>Open React DevTools</li>\n<li>Go to Profiler tab</li>\n<li>Record a profiling session</li>\n<li>Analyze render times and component tree</li>\n</ol>\n<h2>9. Lazy Loading Components</h2>\n<pre><code class=\"language-typescript\">// ✅ Good\nconst ChartComponent = lazy(() =>\n  import('./components/ChartComponent')\n);\n\nfunction Dashboard() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;button onClick={() => setShowChart(true)}>\n        Show Chart\n      &#x3C;/button>\n      {showChart &#x26;&#x26; (\n        &#x3C;Suspense fallback={&#x3C;div>Loading chart...&#x3C;/div>}>\n          &#x3C;ChartComponent />\n        &#x3C;/Suspense>\n      )}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>10. Optimize Context Usage</h2>\n<h3>Split Contexts</h3>\n<pre><code class=\"language-typescript\">// ✅ Good - Separate concerns\nconst ThemeContext = createContext('light');\nconst UserContext = createContext(null);\n\n// ❌ Bad - Combined context\nconst AppContext = createContext({\n  theme: 'light',\n  user: null,\n  settings: {},\n});\n</code></pre>\n<h3>Use Context Selectors</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nfunction ThemeButton() {\n  const theme = useContext(ThemeContext);\n  return &#x3C;button className={theme}>Toggle Theme&#x3C;/button>;\n}\n</code></pre>\n<h2>Best Practices Summary</h2>\n<ol>\n<li><strong>Measure before optimizing</strong> - Use React DevTools Profiler and Web Vitals</li>\n<li><strong>Implement code splitting</strong> for better loading performance</li>\n<li><strong>Use React.memo wisely</strong> - Only for components that re-render frequently with same props</li>\n<li><strong>Memoize expensive calculations</strong> with useMemo</li>\n<li><strong>Stable references</strong> with useCallback for event handlers</li>\n<li><strong>Virtualize large lists</strong> to prevent DOM performance issues</li>\n<li><strong>Optimize images</strong> with proper loading strategies</li>\n<li><strong>Monitor performance</strong> in production with real user metrics</li>\n</ol>\n<h2>Common Performance Anti-Patterns</h2>\n<h3>❌ Don't do this:</h3>\n<pre><code class=\"language-typescript\">// Creating objects in render\nfunction Component() {\n  const style = { color: 'red' }; // Creates new object each render\n  return &#x3C;div style={style}>Content&#x3C;/div>;\n}\n\n// Inline functions in JSX\nfunction Component({ onClick }) {\n  return &#x3C;button onClick={() => onClick()}>Click me&#x3C;/button>;\n}\n\n// Heavy computations without memoization\nfunction Component({ data }) {\n  const processed = data.map(item => heavyComputation(item)); // Runs on every render\n  return &#x3C;div>{processed}&#x3C;/div>;\n}\n</code></pre>\n<p>Remember: <strong>Premature optimization is the root of all evil</strong>. Profile your application first, then optimize the bottlenecks you actually find.</p>\n<p>Happy optimizing! 🚀</p>"
  },
  {
    "title": "TypeScript Best Practices for Scalable Applications",
    "slug": "typescript-best-practices",
    "description": "Essential TypeScript patterns and practices for building maintainable and scalable applications",
    "date": "2024-01-08T00:00:00.000Z",
    "draft": false,
    "featured": false,
    "category": "guide",
    "tags": [
      "typescript",
      "best-practices",
      "development",
      "code-quality"
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 494
    },
    "excerpt": "TypeScript Best Practices for Scalable Applications\nTypeScript has become the standard for building robust web applications. Here are essential best practices to ensure your TypeScript code is maintainable, scalable, and type-safe.\n1. Strict Mode Configuration",
    "content": "<h1>TypeScript Best Practices for Scalable Applications</h1>\n<p>TypeScript has become the standard for building robust web applications. Here are essential best practices to ensure your TypeScript code is maintainable, scalable, and type-safe.</p>\n<h2>1. Strict Mode Configuration</h2>\n<p>Always enable strict mode in your <code>tsconfig.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true\n  }\n}\n</code></pre>\n<h2>2. Use Proper Type Definitions</h2>\n<h3>Avoid <code>any</code> Type</h3>\n<pre><code class=\"language-typescript\">// ❌ Bad\nfunction processData(data: any) {\n  return data.map(item => item.value);\n}\n\n// ✅ Good\nfunction processData(data: Array&#x3C;{ value: string }>) {\n  return data.map(item => item.value);\n}\n</code></pre>\n<h3>Use Union Types for Better Type Safety</h3>\n<pre><code class=\"language-typescript\">// ❌ Bad\nfunction getStatus(status: string) { /* ... */ }\n\n// ✅ Good\ntype Status = 'active' | 'inactive' | 'pending';\nfunction getStatus(status: Status) { /* ... */ }\n</code></pre>\n<h2>3. Interface vs Type Aliases</h2>\n<h3>Use Interfaces for Objects</h3>\n<pre><code class=\"language-typescript\">// ✅ Good for objects\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// ✅ Good for unions and primitives\ntype UserRole = 'admin' | 'user' | 'moderator';\ntype UserId = number;\n</code></pre>\n<h2>4. Generic Constraints</h2>\n<p>Use generics with constraints for better reusability:</p>\n<pre><code class=\"language-typescript\">// ✅ Good\nfunction getProperty&#x3C;T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { id: 1, name: 'John' };\nconst name = getProperty(user, 'name'); // Type: string\n</code></pre>\n<h2>5. Utility Types</h2>\n<p>Leverage TypeScript's built-in utility types:</p>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\n// Create partial version for updates\ntype UserUpdate = Partial&#x3C;User>;\n\n// Make specific fields required\ntype UserProfile = Required&#x3C;Pick&#x3C;User, 'id' | 'name'>>;\n\n// Create read-only version\ntype ReadonlyUser = Readonly&#x3C;User>;\n</code></pre>\n<h2>6. Error Handling</h2>\n<h3>Proper Error Types</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nclass ValidationError extends Error {\n  constructor(public field: string, message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateUser(user: Partial&#x3C;User>): User {\n  if (!user.name) {\n    throw new ValidationError('name', 'Name is required');\n  }\n  // ...\n}\n</code></pre>\n<h2>7. Async/Await Best Practices</h2>\n<h3>Proper Return Types</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\nasync function fetchUser(id: number): Promise&#x3C;User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  return response.json();\n}\n\n// ✅ Good with error handling\nasync function safeFetchUser(id: number): Promise&#x3C;User | null> {\n  try {\n    return await fetchUser(id);\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    return null;\n  }\n}\n</code></pre>\n<h2>8. Module Organization</h2>\n<h3>Barrel Exports</h3>\n<pre><code class=\"language-typescript\">// ❌ Bad - multiple imports\nimport { UserService } from './services/UserService';\nimport { AuthService } from './services/AuthService';\n\n// ✅ Good - barrel export\nimport { UserService, AuthService } from './services';\n</code></pre>\n<h3>Index Files</h3>\n<pre><code class=\"language-typescript\">// services/index.ts\nexport { UserService } from './UserService';\nexport { AuthService } from './AuthService';\nexport { NotificationService } from './NotificationService';\n</code></pre>\n<h2>9. Testing Considerations</h2>\n<h3>Type-Safe Testing</h3>\n<pre><code class=\"language-typescript\">// ✅ Good\ndescribe('UserService', () => {\n  it('should create user with correct type', () => {\n    const user: User = {\n      id: 1,\n      name: 'John Doe',\n      email: 'john@example.com',\n      role: 'user'\n    };\n\n    expect(user.name).toBe('John Doe');\n  });\n});\n</code></pre>\n<h2>10. Performance Considerations</h2>\n<h3>Const Assertions for Performance</h3>\n<pre><code class=\"language-typescript\">// ✅ Better performance\nconst routes = ['/', '/about', '/contact'] as const;\n\n// Type is readonly tuple instead of mutable array\ntype Route = typeof routes[number]; // '/' | '/about' | '/contact'\n</code></pre>\n<h2>Conclusion</h2>\n<p>Following these TypeScript best practices will help you build more maintainable, scalable, and type-safe applications. Remember that TypeScript is a tool to help you catch errors early and improve code quality, but it's not a substitute for good software engineering practices.</p>\n<p>The key is to find the right balance between type safety and developer productivity for your specific use case.</p>"
  },
  {
    "title": "Welcome to Velite",
    "slug": "welcome-to-velite",
    "description": "An introduction to using Velite for content management in Next.js",
    "date": "2024-01-15T00:00:00.000Z",
    "draft": false,
    "featured": true,
    "category": "tutorial",
    "tags": [
      "velite",
      "nextjs",
      "content",
      "markdown"
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 164
    },
    "excerpt": "Welcome to Velite\nVelite is a powerful static site generator that works seamlessly with Next.js. It provides a schema-driven approach to content management with built-in TypeScript support.\nFeatures\n\nSchema-driven content validation with Zod\nMarkdown processin",
    "content": "<h1>Welcome to Velite</h1>\n<p>Velite is a powerful static site generator that works seamlessly with Next.js. It provides a schema-driven approach to content management with built-in TypeScript support.</p>\n<h2>Features</h2>\n<ul>\n<li><strong>Schema-driven content validation</strong> with Zod</li>\n<li><strong>Markdown processing</strong> with remark and rehype plugins</li>\n<li><strong>TypeScript integration</strong> for type-safe content access</li>\n<li><strong>Image optimization</strong> and asset management</li>\n<li><strong>Flexible content organization</strong> with collections</li>\n</ul>\n<h2>Getting Started</h2>\n<p>Here's a simple example of how to use Velite in your Next.js application:</p>\n<pre><code class=\"language-typescript\">import { posts } from '.velite'\n\n// Access all posts\nconst allPosts = posts\n\n// Find a specific post\nconst post = posts.find(p => p.slug === 'welcome-to-velite')\n</code></pre>\n<h2>Content Structure</h2>\n<p>Velite organizes content into collections defined in your <code>velite.config.ts</code> file. Each collection has its own schema and processing rules.</p>\n<p>The content structure looks like this:</p>\n<pre><code>content/\n├── posts/          # Blog posts\n├── pages/          # Static pages\n└── authors/        # Author information\n</code></pre>\n<h2>Next Steps</h2>\n<ol>\n<li>Create more content in your collections</li>\n<li>Customize your Velite configuration</li>\n<li>Build pages using the generated data</li>\n<li>Deploy your static site</li>\n</ol>\n<p>Happy coding! 🚀</p>"
  }
]